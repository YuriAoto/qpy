#!/usr/bin/python
# qpy - queueing manager for qpy
#
# 29 May 2015 - Pradipta and Yuri
from multiprocessing.connection import Client
from time import sleep
import os
import sys
import subprocess
import re
import threading
from qpy_general_variables import *

import unittest as ut


qpy_source_dir = os.path.dirname( os.path.abspath( __file__)) + '/'
test_run = os.path.isfile( qpy_source_dir + 'test_dir')
home_dir = os.environ['HOME']
user = os.environ['USER']
if (test_run):
    qpy_dir = os.path.expanduser( '~/.qpy-test/')
else:
    qpy_dir = os.path.expanduser( '~/.qpy/')
port_file = qpy_dir + '/port'
key_file = qpy_dir + '/conn_key'
tutorial_file = qpy_source_dir + '/tutorial'

scr_dir = '/scratch/' + user

qpy_finish_command = [qpy_source_dir + 'qpy', 'finish', '>', '/dev/null', '2>', '/dev/null']
qpy_master_command = ['python', qpy_source_dir + 'qpy-master.py', '>', '/dev/null', '2>', '/dev/null']

class ProcessHandle(object):
    def __init__(self, pid, cmd, parent_pid):
        self._pid = pid
        self.command = cmd
        self._parent_pid = parent_pid

    def is_parent_of(self, other):
        return self._pid == other._parent_pid

class BashAdapter(object):


    #---------------------------------------------------------
    ## Retrieves all active processes 
    ##
    ## @param user[in] name of the user for which  processes are retrieved
    ## @return a list of ProcessHandles 
    ## @raises a subprocess.CalledProcessError if the retirval fails
    def get_active_processes(self, user):
        job_ps = subprocess.Popen(["ps", "-fu", str(user)],
                                  shell = False,
                                  stdout = subprocess.PIPE,
                                  stderr = subprocess.PIPE)
        line_tuples = [proc.split(None,7)  for proc in job_ps.stdout.readlines()]
        return [ ProcessHandle(proc_tuple[1],proc_tuple[-1],proc_tuple[2]) for proc_tuple in  line_tuples]


    def kill_process(self, proc):
        """ ends a process
        @param proc a ProcessHandle
        """
        
        pid = proc._pid
        try:
            subprocess.check_call(['kill', str(pid)])
        except subprocess.CalledProcessError as ex:
            pass
        sleep(1)
        try:
            subprocess.check_output(['kill','-9', str(pid)])
        except subprocess.CalledProcessError as ex:
            pass

# Return a list with all children and grand-children from pid
# The dict parent_of shows the parents of all processes
def get_all_children( pid, parent_of):
    cur_child = []
    for p in parent_of:
        if (parent_of[p] == pid):
            cur_child.append(p)
    all_children = []
    for c in cur_child:
        all_children = get_all_children( c, parent_of)
    all_children.extend( cur_child)
    return all_children

def jobkill(jobid):
    def find_job( jobid, proc_list):
        for process in proc_list:
            if re.search('export QPY_JOB_ID={job_id};'.format(job_id=str(jobid)),
                         process.command)is not None:
                return process
        raise Exception("Job {job_id} NotFound".format(job_id=str(jobid) ))

    shell = BashAdapter()
    process_list = shell.get_active_processes(user=user)

    child_list = [ find_job(jobid, process_list)] #initialize the child list with origin process
    kill_list = []
    while child_list != []:
        current = child_list.pop()
        child_list.extend([ job for job in process_list if current.is_parent_of(job)])
        kill_list.append(current)
    for job in reversed(kill_list):
        shell.kill_process(job)
        print 'Killing PID ' + job._pid

# '--options' are to be called only by qpy-master, not by the users
if (len( sys.argv) > 1):
    if (sys.argv[1] == '--jobkill'):
        job_id = sys.argv[2]
        jobkill(job_id)
        exit()
# end of '--options'


# Return a list of integers, described by the string X, as following:
#
# '1,2,3'    -> [1,2,3]
# '1-3'      -> [1,2,3]
# '1-3,6-10' -> [1,2,3,6,7,8,9,10]
#
def string_to_int_list( string):
    res = []
    for entry in string.split(',') :
        range_ = [ int(num) for num in entry.split('-')] # raises ValueError on 3-
        if (len(range_) not in [1,2] ):
            raise IndexError("No multivalue ranges")
        res.extend( range( range_[0], range_[-1]+1)) #works correctly for len(range_ ) == 1
    return res


job_status = ['queue', 'running', 'done', 'killed', 'undone']

keywords={'sub':       (JOBTYPE_SUB       , 'Submit a job. Arguments: the job command'),
          'check':     (JOBTYPE_CHECK     , 'Check the jobs. Arguments: the desired job status'),
          'kill':      (JOBTYPE_KILL      , 'Kill jobs. Argument: the jobs id'),
          'finish':    (JOBTYPE_FINISH    , 'Finish the master execution. No arguments'),
          'config':    (JOBTYPE_CONFIG    , 'Show the current configuration. No arguments'),
          'clean':     (JOBTYPE_CLEAN     , 'Remove finished jobs from the list. Arguments: the jobs id'),
          'tutorial':  (JOBTYPE_TUTORIAL  , 'Run the qpy tutorial. Arguments: optional: a qpy option'),
          'status':    (JOBTYPE_STATUS    , 'Show current status. No arguments'),
          'restart':   (JOBTYPE_RESTART   , 'Restart qpy-master. No arguments'),
          'ctrlQueue': (JOBTYPE_CTRLQUEUE , 'Fine control over the queue. Arguments: see tutorial'),
          'notes':     (JOBTYPE_NOTE      , 'Add and read notes. Arguments: ID and the note')
          }

def usage_message(keywords):
    def get_max_wordlength(words):
        length = 0
        for word in words:
            length = max(length, len(word))
        return length
    
    length = get_max_wordlength(keywords)+1
    format_spc = '{0:' + str( length) + 's}'
    usage_msg =  'Usage: {prog} <option> [<arguments>].\n'.format(prog=sys.argv[0])
    usage_msg += 'Options:'
    for opt in keywords:
        usage_msg += '\n {option} {usage}'.format(option=format_spc.format( opt+':'),
                                                  usage= keywords[opt][1] )
    return usage_msg


def jobpattern_to_list(arguments,allowed_statuses):
    ret = []
    for argument in arguments:
        try:
            ret.extend(string_to_int_list(argument))
        except:
            if (argument == 'all'
                    or argument in allowed_statuses):
               ret.append(argument)
            else:
                sys.exit('Range with wrong format or invalid status: ' + argument)
    return list(set(ret))


try:
    option = keywords[sys.argv[1]][0]
except:
    sys.exit( usage_message(keywords))

start_qpy_master = option == JOBTYPE_RESTART
if (start_qpy_master):
    option = JOBTYPE_FINISH

# Get arguments, according to the option
arguments = ()

# Submit a job
if (option == JOBTYPE_SUB):
    job = " ".join(sys.argv[2:])
    arguments = [job, os.getcwd()]

# Check jobs
if (option == JOBTYPE_CHECK):
    arguments = {}
    for x in sys.argv[2:]:
        if x in job_status:
            arguments.setdefault("status",[]).append(x)
        else:
            try:
                new_jobids = string_to_int_list( x)
            except:
                sys.exit( 'Unknown pattern for checking jobs: ' + x)
            else:
                arguments.setdefault("job_id",[]).extend(new_jobids)

# Config
elif (option == JOBTYPE_CONFIG):
    if (len( sys.argv) == 4):
        arguments = ( sys.argv[2], sys.argv[3])
    elif (len( sys.argv) > 2 and sys.argv[2] == 'coloursScheme'):
        if( len( sys.argv) == 8):
            arguments = ( sys.argv[2], sys.argv[3:])
        else:
            sys.exit( 'Give five colours for coloursScheme')
    elif (len( sys.argv) != 2):
        sys.exit( 'Give, optionally, a pair <key> <value> for the config option')

# Kill jobs or clean list
elif (option == JOBTYPE_KILL or option == JOBTYPE_CLEAN):
    if option == JOBTYPE_KILL:
        status_bound = (0,2)
    else:
        status_bound = (2,5)
    arguments = jobpattern_to_list(sys.argv[2:],job_status[status_bound[0]:status_bound[1]])

# Control queue
elif (option == JOBTYPE_CTRLQUEUE):
    if (len( sys.argv) < 3):
        sys.exit( 'Give the queue control type.')
    else:
        if (sys.argv[2] == 'jump'):
            new_range = []
            for x in sys.argv[3:-1]:
                try:
                    new_range.extend( string_to_int_list( x))
                except:
                    sys.exit( 'Range with wrong format: ' + x)
            if (not( new_range)):
                    sys.exit( 'Give the jobs to change position.')
            try:
                pos = int( sys.argv[-1])
            except:
                if (sys.argv[-1] == 'begin'):
                    pos = 0
                elif (sys.argv[-1] == 'end'):
                    pos = -1
                else:
                    sys.exit( 'Invalid jump position: ' + sys.argv[-1])
            arguments = ('jump', new_range, pos)

        else:
            arguments = sys.argv[2:]

# Control queue
elif (option == JOBTYPE_NOTE):
    if (len( sys.argv) < 3):
        arguments = ()
    elif (len( sys.argv) == 3):
        arguments = [ sys.argv[2]]
    else:
        arguments = [ sys.argv[2], ' '.join( sys.argv[3:])]

# The qpy tutorial
elif (option == JOBTYPE_TUTORIAL):
    
    pattern = ''
    for i in sys.argv[2:3]:
        pattern += i
    for i in sys.argv[3:]:
        pattern += ' ' + i

    if (pattern in keywords):
        pattern = '--pattern "# ' + pattern + '"'
    elif (pattern):
        pattern = '--pattern "' + pattern + '"'

    command = 'less '  + pattern + ' ' + tutorial_file
    try:
        subprocess.call( command, shell = True)
    except:
        sys.exit( 'Error when loading the tutorial.')
    exit()


def kill_master_instances():
    pattern = ' '.join( qpy_master_command)
    ps = subprocess.Popen(["ps", "-fu", user],
                          shell=False,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
    std_outerr = ps.communicate()
    ps_stdout = std_outerr[0].split( '\n')
    for l in ps_stdout:
        if (pattern in l):
            pid = l.split()[1]
            kill = subprocess.Popen(["kill", pid],
                                    shell=False,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            sys.stdout.write( 'Killing older qpy-master instance: ' + pid + '\n')
            std_outerr = kill.communicate()


def start_master_driver():
    sys.stdout.write( "Starting qpy-master driver.\n")
    sleep( 1)
#    kill_master_instances()
    subprocess.Popen( qpy_master_command, shell = False)
    exit()

def retrieve_port(port_file=port_file):
    with open(port_file,'r') as f:
        return int( f.read())

def retrieve_conn_key(key_file=key_file):
    with open( key_file, 'r') as f:
        return  f.read()
try:
    port = retrieve_port()
    conn_key = retrieve_conn_key()
except:
    if (start_qpy_master):
        start_master_driver()
    else:
        sys.exit( 'Problem to get the connection information. Are you sure that qpy-master is running?')

address = 'localhost'

class try_connection( threading.Thread):
    def __init__( self):
        threading.Thread.__init__( self)
        self.conn = None
        self.done = threading.Event()

    def run( self):
        try:
            self.conn = Client( (address, port), authkey=conn_key)
            self.done.set()
        except:
            self.done.clear()

M = try_connection()
M.daemon = True
M.start()
M.done.wait( 3.0)
if (not( M.done.is_set())):
    if (start_qpy_master):
        os.remove( port_file)
        start_master_driver()
    sys.exit( 'Time for connection exceeded. Are you sure that qpy-master is running?')

conn = M.conn
conn.send( (option, arguments))
try:
    ansi_escape = re.compile(r'\x1b[^m]*m')
    master_msg = conn.recv()
    if (not( sys.stdout.isatty())):
        master_msg = ansi_escape.sub('', master_msg)
    sys.stdout.write( master_msg)
except:
    sys.exit( 'Problem when getting message from qpy-master. Your qpy-master might be broken.\nTry to run again or contact the qpy-team.')
conn.close()

if (start_qpy_master):
    start_master_driver()
