#!/usr/bin/python
# qpy - queueing manager for qpy
#
# 29 May 2015 - Pradipta and Yuri
from multiprocessing.connection import Client
from time import sleep
import os
import sys
import subprocess
import re
import threading
from qpy_general_variables import *

import unittest as ut
import test_util

 
qpy_source_dir = os.path.dirname( os.path.abspath( __file__)) + '/'
test_run = os.path.isfile( qpy_source_dir + 'test_dir')
home_dir = os.environ['HOME']
user = os.environ['USER']
if (test_run):
    qpy_dir = os.path.expanduser( '~/.qpy-test/')
else:
    qpy_dir = os.path.expanduser( '~/.qpy/')
port_file = qpy_dir + '/port'
key_file = qpy_dir + '/conn_key'
tutorial_file = qpy_source_dir + '/tutorial'

scr_dir = '/scratch/' + user

qpy_finish_command = [qpy_source_dir + 'qpy', 'finish', '>', '/dev/null', '2>', '/dev/null']
qpy_master_command = ['python', qpy_source_dir + 'qpy-master.py', '>', '/dev/null', '2>', '/dev/null']


            
            
class SendingError(Exception):
    pass




class ProcessHandle(object):
    """ internal representation of a process

    If we kill a job, we also want to kill all children of this process
    """
    def __init__(self, pid, cmd, parent_pid):
        self._pid = pid
        self.command = cmd
        self._parent_pid = parent_pid

    def is_parent_of(self, other):
        """ probes if self is the parent process of the other process"""
        return self._pid == other._parent_pid


    
class BashAdapter(object):
    """ contains all interactions with the shell 
    """

    def get_active_processes(self, user):
        """ Retrieves all active processes for a  user
        
        @param user[in] name of the user for which  processes are retrieved
        @return a list of ProcessHandles 
        @raises a subprocess.CalledProcessError if the retival fails
        """
        job_ps = subprocess.Popen(["ps", "-fu", str(user)],
                                  shell = False,
                                  stdout = subprocess.PIPE,
                                  stderr = subprocess.PIPE)
        line_tuples = [proc.split(None,7)  for proc in job_ps.stdout.readlines()]
        return [ ProcessHandle(proc_tuple[1],proc_tuple[-1],proc_tuple[2]) for proc_tuple in  line_tuples]


    def kill_process(self, proc):
        """ ends a process

        @param proc a ProcessHandle
        """
        
        pid = proc._pid
        try:
            subprocess.check_call(['kill', str(pid)])
        except subprocess.CalledProcessError as ex:
            pass
        sleep(1)
        try:
            subprocess.check_output(['kill','-9', str(pid)])
        except subprocess.CalledProcessError as ex:
            pass

# Return a list with all children and grand-children from pid
# The dict parent_of shows the parents of all processes
def get_all_children( pid, parent_of):
    cur_child = []
    for p in parent_of:
        if (parent_of[p] == pid):
            cur_child.append(p)
    all_children = []
    for c in cur_child:
        all_children = get_all_children( c, parent_of)
    all_children.extend( cur_child)
    return all_children

def jobkill(jobid):
    """ kills a job with a given Jobid"""
    def find_job( jobid, proc_list):
        for process in proc_list:
            if re.search('export QPY_JOB_ID={job_id};'.format(job_id=str(jobid)),
                         process.command)is not None:
                return process
        raise Exception("Job {job_id} NotFound".format(job_id=str(jobid) ))

    shell = BashAdapter()
    process_list = shell.get_active_processes(user=user)

    child_list = [ find_job(jobid, process_list)] #initialize the child list with origin process
    kill_list = []
    while child_list != []:
        current = child_list.pop()
        child_list.extend([ job for job in process_list if current.is_parent_of(job)])
        kill_list.append(current)
    for job in reversed(kill_list):
        shell.kill_process(job)
        print 'Killing PID ' + job._pid




# Return a list of integers, described by the string X, as following:
#
# '1,2,3'    -> [1,2,3]
# '1-3'      -> [1,2,3]
# '1-3,6-10' -> [1,2,3,6,7,8,9,10]
#
def string_to_int_list( string):
    res = []
    for entry in string.split(',') :
        range_ = [ int(num) for num in entry.split('-')] # raises ValueError on 3-
        if (len(range_) not in [1,2] ):
            raise IndexError("No multivalue ranges")
        res.extend( range( range_[0], range_[-1]+1)) #works correctly for len(range_ ) == 1
    return res


job_status = ['queue', 'running', 'done', 'killed', 'undone']

keywords={'sub':       (JOBTYPE_SUB       , 'Submit a job. Arguments: the job command'),
          'check':     (JOBTYPE_CHECK     , 'Check the jobs. Arguments: the desired job status'),
          'kill':      (JOBTYPE_KILL      , 'Kill jobs. Argument: the jobs id'),
          'finish':    (JOBTYPE_FINISH    , 'Finish the master execution. No arguments'),
          'config':    (JOBTYPE_CONFIG    , 'Show the current configuration. No arguments'),
          'clean':     (JOBTYPE_CLEAN     , 'Remove finished jobs from the list. Arguments: the jobs id'),
          'tutorial':  (JOBTYPE_TUTORIAL  , 'Run the qpy tutorial. Arguments: optional: a qpy option'),
          'status':    (JOBTYPE_STATUS    , 'Show current status. No arguments'),
          'restart':   (JOBTYPE_RESTART   , 'Restart qpy-master. No arguments'),
          'ctrlQueue': (JOBTYPE_CTRLQUEUE , 'Fine control over the queue. Arguments: see tutorial'),
          'notes':     (JOBTYPE_NOTE      , 'Add and read notes. Arguments: ID and the note')
          }

def usage_message(keywords):
    def get_max_wordlength(words):
        length = 0
        for word in words:
            length = max(length, len(word))
        return length
    
    length = get_max_wordlength(keywords)+1
    format_spc = '{0:' + str( length) + 's}'
    usage_msg =  'Usage: {prog} <option> [<arguments>].\n'.format(prog=sys.argv[0])
    usage_msg += 'Options:'
    for opt in keywords:
        usage_msg += '\n {option} {usage}'.format(option=format_spc.format( opt+':'),
                                                  usage= keywords[opt][1] )
    return usage_msg +"\n"


def jobpattern_to_list(arguments,allowed_statuses):
    ret = []
    for argument in arguments:
        try:
            ret.extend(string_to_int_list(argument))
        except:
            if (argument == 'all'
                    or argument in allowed_statuses):
               ret.append(argument)
            else:
                sys.exit('Range with wrong format or invalid status: ' + argument)
    return list(set(ret))

class Printer(object):
    """ Prints to an output stream 

    responsible for removing colouring if a master_string is printed to a file
    """
    def __init__(self, out):
        """ 
        
        takes an output stream (with a write method and a isatty method)
        """
        self.out = out

    def print_(self, msg):
        """ prints to the output stream

        """
        if not self.out.isatty():
            ansi_escape = re.compile(r'\x1b[^m]*m')
            msg = ansi_escape.sub('', msg)
        self.out.write(msg)


class Parser(object):
    """ Registers actions and invokes them based on the commandline option

    """
    def __init__(self, sender, printer, shell):
        """ 
        @param sender a connector to the server
        @param printer prints to output
        @param shell shell adapter
        """
        self.user_actions = {}
        self.server_actions = {}
        self.printer = printer
        self._args = (sender,printer,shell)

    def register_user_action(self, options):
        """ decorator for actions that may be taken by the user.

        usage:
        >> @parser.register_user_action("kill")
        >> class Kill...

        >> @parser.register_user_action(["sub","submit"])
        >> class Submit... 

        """
        def register_core(cls):
            if isinstance(options, str):
                self.user_actions[options] = cls
            else:
                for option in options:
                    self.user_action[options]=cls
            return cls
        return register_core

    def register_server_action(self, options):
        """ Decorator for actions that may be taken by the server.

        >> @parser.register_server_action("jobkill")
        >> class Jobkill...
        """
        def register_core(cls):
            if isinstance(options, str):
                self.server_actions[str] = cls
            else:
                for option in options:
                    self.server_action[str]=cls
            return cls
        return register_core
    
    def parse(self, args=sys.argv):
        """ parses some arguments and creates and executes the assigned command"""
        try:
            actioncls=self._get_action( args[1:])
        except (IndexError, KeyError) :
            self.printer.print_(usage_message(keywords))
        else:
            action= actioncls(*self._args, arguments=args[2:])
            sys.exit(action.execute())
    
    def _get_action(self, args):
        if args[0] == "--option":
            return self.server_actions[args[1]]
        else:
            return self.user_actions[args[0]]

def retrieve_port(port_file=port_file):
    with open(port_file,'r') as f:
        return int( f.read())

def retrieve_conn_key(key_file=key_file):
    with open( key_file, 'r') as f:
        return  f.read()

class ConnectionThread(threading.Thread):
    """ Threaded connector to the server"""
    def __init__(self, clientfactory):
        """ Takes a clientfactory, which will be called without arguments to create a client"""
        threading.Thread.__init__(self)
        self.conn = None
        self.done = threading.Event()
        self.clientfactory =clientfactory

    def run(self):
        """ call start if you want to run it."""
        try:
            self.conn = self.clientfactory()
            self.done.set()
        except:
            self.done.clear()

class Sender(object):
    """ encapsulates the commutincation protokoll to the server.

    usage:
    >> with Sender(...) as sender:
    >>      ret_msg = sender.send(msg)
    """
    def __init__( self, address, port, conn_key, connectionthread_factory= ConnectionThread, client_factory=Client):
        self._thread = connectionthread_factory(lambda:client_factory( ( address, port), authkey = conn_key))
        self._thread.daemon = True

    def __enter__(self):
            self._thread.start()
            self._thread.done.wait(3.0)
            if ( not (self._thread.done.is_set())):
                    raise SendingError("Connection timed out. Are you sure that qpy-master is running?")
            return self
            
    def send (self , msg):
        self._thread.conn.send(msg)
        return self._thread.conn.recv()

    def __exit__(self, *args):
        self._thread.conn.close()


port = None
conn_key = None
try:
    port = retrieve_port()
    conn_key = retrieve_conn_key()
except:
    pass

address = 'localhost'




#########################################################################################################################################################################
#                              actual actions

parser = Parser(Sender( address,port,conn_key),
                    Printer(sys.stdout),
                    BashAdapter())

class ActionDocumentation(object):
    def __init__(self ,  arguments=[""], description=""):
        self.arguments = arguments
        self.description = description
        
class Action(object):
    """ Base class for any public action"""
    def __init__(self, sender, printer, shell, arguments = sys.argv[2:]):
        pass

#####################################################
class ServerAction(Action):
    """ base class for any action the qpy-master might trigger"""
    pass


@parser.register_server_action("jobkill")
class Jobkill(ServerAction):
    """ kills a job with a given jobid and all its child processes

    note: jobid is an qpy-jobid not a process id
    """
    documentation=ActionDocumentation(arguments=['<JOBID> a qpy-jobid'],description="someone forgot to add a description")
    def execute(self):
        job_id = int(self.args[0])
        jobkill(job_id)
        return 0

######################################################
class UserAction(object):
    option = None
    def __init__(self, sender, printer, shell, arguments=sys.argv[2:] ):
        self.sender = sender
        self.printer = printer
        self.shell = shell
        self.args = arguments
        
    
    def execute(self):
        NotImplemented




@parser.register_user_action("tutorial")
class Tutorial(UserAction):
    @property
    def arguments(self):
        return None
    def execute(self):
        command = ["less"]
        if len(self.args)==1:
           pattern = self.args[0]
           command += ['--pattern',"# {pattern}".format(pattern=pattern)] if pattern in keywords else ['--pattern','{pattern} '.format(pattern=pattern)]
        command += [tutorial_file]
        try:
            subprocess.call(command ,
                                shell = False)
        except:
            sys.exit( 'Error when loading the tutorial.')
        exit()
#############
class SendingAction(UserAction):
    """ Base class for all actions that send something to the server

    child classes need to implement the arguments and option property
    """
    def execute(self):
        arguments = self.arguments
        with self.sender as sender:
            master_message = sender.send( (self.option, arguments))
            self.printer.print_(master_message)
        return 0
                
        
        

@parser.register_user_action("sub")        
class Submit(SendingAction):
    documentation = ActionDocumentation(arguments= "<cmd1> <cmd2> ... ; the parts of a commando to be submitted",
                                            description="Submits an commando for execution to qpy-master")
    option = JOBTYPE_SUB
    @property
    def arguments(self):
        job = " ".join(self.args)
        return [job, os.getcwd()]


@parser.register_user_action("check")
class Check(SendingAction):
    option = JOBTYPE_CHECK
    @property
    def arguments(self):
        arguments = {}
        for x in self.args :
            if x in job_status:
                arguments.setdefault("status",[]).append(x)
            else:
                try:
                    new_jobids = string_to_int_list( x)
                except:
                    sys.exit( 'Unknown pattern for checking jobs: ' + x)
                else:
                    arguments.setdefault("job_id",[]).extend(new_jobids)
        return arguments
                    

@parser.register_user_action("kill")
class Kill(SendingAction):
    option = JOBTYPE_KILL
    killable_statuses = ('queue', 'running')
    @property
    def arguments(self):
        return jobpattern_to_list(self.args, self.killable_statuses)

@parser.register_user_action("clean")
class Clean(SendingAction):
    option = JOBTYPE_CLEAN
    cleanable_statuses = ( 'done', 'killed', 'undone')
    @property
    def arguments(self):
        return jobpattern_to_list(self.args, self.cleanable_statuses)

@parser.register_user_action("ctrlQueue")
class ControlQueue(SendingAction):
    option = JOBTYPE_CTRLQUEUE
    @property
    def arguments(self):
        if len(self.args)<1:
            sys.exit('Give an action for the queue.')
        elif (self.args[0] == 'jump'):
            new_range = []
            for x in self.args[1:-1]:
                try:
                    new_range.extend( string_to_int_list( x))
                except:
                    sys.exit( 'Range with wrong format: ' + x)
            if (not( new_range)):
                    sys.exit( 'Give the jobs to change position.')
            try:
                pos = int( self.args[-1])
            except:
                if (self.args[-1] == 'begin'):
                    pos = 0
                elif (self.args[-1] == 'end'):
                    pos = -1
                else:
                    sys.exit( 'Invalid jump position: ' + self.args[-1])
            return ('jump', new_range, pos)

        else:
            return self.args
            

@parser.register_user_action("notes")
class Notes(SendingAction):
    option = JOBTYPE_NOTE
    @property
    def arguments(self):
        if len(self.args) <1:
            return ()
        elif(len( self.args) == 1):
            return self.args
        else:
            return [self.args[0]," ".join(self.args[1:])]

@parser.register_user_action("config")
class Config( SendingAction):
    option = JOBTYPE_CONFIG
    @property
    def arguments(self):
        if len(self.args) == 2:
            return (self.args[0],self.args[1])
        elif len(self.args)>0 and self.args[0] == 'coloursScheme':
            if( len( self.args) == 6):
                return ( self.args[0], self.args[1:])
            else:
                sys.exit( 'Give five colours for coloursScheme')
        elif (len(self.args)) != 0:
            sys.exit( 'Give, optionally, a pair <key> <value> for the config option')
        else:
            return ()
        

@parser.register_user_action("restart")
class Restart(SendingAction):
    option = JOBTYPE_FINISH
    @property
    def arguments(self):
        return ()
    def execute(self):
        try:
            SendingAction.execute(self)
        except SendingError:    
            os.remove( port_file)
        finally:
            start_master_driver()

@parser.register_user_action("finish")
class Finish(SendingAction):
    option = JOBTYPE_FINISH
    @property
    def arguments(self):
        return ()
            


def start_master_driver():
    sys.stdout.write( "Starting qpy-master driver.\n")
    sleep( 1)
    subprocess.Popen( qpy_master_command, shell = False)
    exit()

def retrieve_port(port_file=port_file):
    with open(port_file,'r') as f:
        return int( f.read())

def retrieve_conn_key(key_file=key_file):
    with open( key_file, 'r') as f:
        return  f.read()


    


def kill_master_instances():
    pattern = ' '.join( qpy_master_command)
    ps = subprocess.Popen(["ps", "-fu", user],
                          shell=False,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
    std_outerr = ps.communicate()
    ps_stdout = std_outerr[0].split( '\n')
    for l in ps_stdout:
        if (pattern in l):
            pid = l.split()[1]
            kill = subprocess.Popen(["kill", pid],
                                    shell=False,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            sys.stdout.write( 'Killing older qpy-master instance: ' + pid + '\n')
            std_outerr = kill.communicate()


def start_master_driver():
    sys.stdout.write( "Starting qpy-master driver.\n")
    sleep( 1)
    subprocess.Popen( qpy_master_command, shell = False)
    exit()



####################################################################################################
#                   TestClasses
collector = test_util.TestCollector()

@collector.collect
class TestPrinter(ut.TestCase):
    class MockOutStream(object):
        def __init__(self, tty =True):
            self.tty = tty
        def write(self,message):
            self.msg = message

        def isatty(self):
            return self.tty

    def test_tty(self):
        """ on tty output the colour are retained"""
        out = self.MockOutStream(True)
        Printer(out).print_('\033[1mdfa\033[0m')
        self.assertEqual(out.msg , "\033[1mdfa\033[0m")

    def test_nottty(self):
        """for non tty output the colour escape sequences are removed"""
        out = self.MockOutStream(False)
        Printer(out).print_('\033[40mdfa\033[0m')
        self.assertEqual(out.msg , "dfa")
        
    def test_nottty_beginm(self):
        """after an escape sequence the word may begin with a non removed m"""
        out = self.MockOutStream(False)
        Printer(out).print_('\033[30mmfa\033[0m')
        self.assertEqual(out.msg , "mfa")

@collector.collect
class TestSender(ut.TestCase):
    class MockConnectionThread(object):
        class MockEvent(object):
            def __init__(self):
                self.fl = False
                self._err = False

            def wait(self, timeout):
                self.fl = not self._err

            def is_set(self):
                return self.fl

            def set(self):
                self.fl=True

            def clear(self):
                self.fl =False
                
        def __init__(self,clientfactory):
            self.conn = None
            self.done = self.MockEvent()
            self.factory = clientfactory
            self.daemon = False
            self._err = False
            
        def start(self):
            self.conn = self.factory()
            self.done._err = self._err

    class MockClient(object):
        master_msg = "This is your master"
        def __init__(self, *args,**kwargs):
            pass
        
        def send(self, msg):
            self._msg = msg
            
        def recv(self):
            return self.master_msg
        def close(self):
            self._is_closed = True
        
        
        
    def test_successfull(self):
        with Sender("localhost", 1123, "asdf", self.MockConnectionThread, self.MockClient) as sender:
            self.assertEqual(sender.send((2,"go there")), "This is your master")
        self.assertTrue(sender._thread.daemon )
        self.assertTrue(sender._thread.conn._is_closed)
            


if __name__ == "__main__":
# to test, uncomment the following two line
#       collector.run()
#       sys.exit()
        parser.parse(sys.argv)
