#!/usr/bin/python
# qpy - control the nodes distribution for several users
#
# 26 December 2015 - Pradipta and Yuri
# 06 January 2016 - Pradipta and Yuri
from multiprocessing.connection import Client
from multiprocessing.connection import Listener
from time import sleep
import os
import sys
import subprocess
import re
import threading
import math
from optparse import OptionParser

from qpy_general_variables import *


# Important variables
nodes_file = '/home/linux4_i2/aoto/Codes/qpy/multiuser_nodes'
allowed_users_file = '/home/linux4_i2/aoto/Codes/qpy/multiuser_allowed_users'
nodes_distribution_file = '/home/linux4_i2/aoto/Codes/qpy/multiuser_distribution_rules'

nodes = {}
users = {}
N_cores = 0
N_min_cores = 0
N_jobs  = 0
N_min_jobs = 0

multiuser_address = 'localhost'
multiuser_key = 'zxcvb'
multiuser_port = 9998

parser = OptionParser()
parser.add_option("-v", "--verbose",
                  action="store_true", dest="verbose", default=False,
                  help="print messages")
(options, args) = parser.parse_args()
verbose = options.verbose


# Node informations
class NODE():
    def __init__( self, max_jobs):
        self.max_jobs = max_jobs
        self.n_jobs = 0


# User informations
class USER():
    def __init__( self, name):
        self.name = name
        self.min_cores = 0
        self.extra_cores = 0
        self.max_cores = 0
        self.cur_jobs = []
        self.n_jobs = 0
        self.n_queue = 0

    def add_job( self, jobID, num_cores):
        global N_jobs, N_min_jobs
        space_available = False
        
        N_free_cores = (N_cores - N_jobs) - (N_min_cores - N_min_jobs)
        free_cores = N_free_cores >= num_cores

        if (self.n_jobs + num_cores <= self.min_cores):
            space_available = True

        else:
            use_others_resource = self.n_jobs >= self.min_cores + self.extra_cores
            if (use_others_resource):

                N_users_with_queue = 1
                N_extra = 0
                for user,info in users.iteritems():
                    if (user == self.name):
                        continue
                
                    if (info.n_queue > 1 and info.n_jobs >= info.min_cores + info.extra_cores):
                        N_users_with_queue += 1

                    elif (info.n_queue == 0):
                        N_extra += min(info.extra_cores + info.min_cores - info.n_jobs, info.extra_cores)

                N_extra_per_user = N_extra/N_users_with_queue
                if (self.n_jobs + num_cores <= self.min_cores + self.extra_cores + N_extra_per_user and free_cores):
                    space_available = True
                    
            else:

                N_users_free = 1
                N_used_extra = 0
                N_extra_cores_per_user_free = self.extra_cores
                for user,info in users.iteritems():
                    if (user == self.name):
                        continue
                    
                    n_extra_user = info.n_jobs - info.min_cores - info.extra_cores
                    if (n_extra_user > 0):
                        N_used_extra += n_extra_user
                    elif (n_extra_user < 0 and info.n_queue > 0):
                        N_extra_cores_per_user_free += info.extra_cores
                        N_users_free += 1


                N_free_per_user = (N_extra_cores_per_user_free - N_used_extra)/N_users_free
                if (self.n_jobs + num_cores <= self.min_cores + N_free_per_user and free_cores):
                    space_available = True


        if (space_available):
            best_node = None
            best_free = 0
            for node, info in nodes.iteritems():
                # Evenly distributing
                #free = info.max_jobs - info.n_jobs
                #if (free > best_free and free >= num_cores):
                #    best_node = node
                #    best_free = free
                # first nodes first
                if (info.max_jobs - info.n_jobs  >= num_cores):
                    best_node = node

            if (best_node == None):
                return (1, 'No node with this requirement.')

            self.cur_jobs.append( [jobID, best_node, num_cores])
            self.n_jobs += num_cores
            nodes[best_node].n_jobs += num_cores
            N_jobs += num_cores

            if (self.n_jobs < self.min_cores):
                N_min_jobs += num_cores
            if (self.n_jobs < self.min_cores + num_cores):
                N_min_jobs += num_cores + self.min_cores - self.n_jobs

            return (0, best_node)

        return (2, 'No free cores.')

    def remove_job( self, jobID):
        global N_jobs, N_min_jobs
        removed = False
        for j in self.cur_jobs:
            if (j[0] == jobID):
                self.n_jobs -= j[2]
                nodes[j[1]].n_jobs -= j[2]
                N_jobs -= j[2]
                if (self.n_jobs < self.min_cores):
                    N_min_jobs -= j[2] + self.min_cores - self.n_jobs
                self.cur_jobs.remove( j)
                return (0, 'Job removed.')
        return (1, 'Job not found.')


# Load nodes file
def load_nodes():
    global N_cores
    if (os.path.isfile( nodes_file)):
        f = open( nodes_file, 'r')
        nodes_in_file = []
        for line in f:
            line_spl = line.split()
            name = line_spl[0]
            cores = int( line_spl[1])
            nodes_in_file.append( name)
            if (name in nodes):
                N_cores += cores - nodes[name].max_jobs
                nodes[name].max_jobs = cores
            else:
                new_node = NODE( cores)
                nodes[name] = new_node
                N_cores += new_node.max_jobs
        f.close()
        not_in_file = []
        for node in nodes:
            if (not( node in nodes_in_file)):
                not_in_file.append(node)
        for node in not_in_file:
            nodes.pop( node)


# Distribute cores
def distribute_cores( ):
    f = open( nodes_distribution_file, 'r')
    line = f.readline()
    line_spl = line.split()
    dist_type = line_spl[0]
    min_cores = 0
    users_min = {}
    users_extra = {}
    if (verbose):
        print "distribute_cores:"
        print 'dist_type: ' + dist_type
    if (len( line_spl) > 1):
        if (line_spl[1] != 'minimum'):
            return -1
        try:
            min_cores = int(line_spl[2])
        except:
            return -1

    left_cores = N_cores
    for user in users:
        users_min[user] = min_cores
        left_cores -= min_cores
    if (left_cores < 0):
        return -2

    if (dist_type == 'even'):
        n_users = len( users)
        if (n_users == 0):
            return 0
        N_per_user = left_cores/n_users
        for user in users:
            users_extra[user] = N_per_user
        left_cores = left_cores - N_per_user*n_users

    elif (dist_type == 'explicit'):
        for line in f:
            line_spl = line.split()
            user = line_spl[0]
            if (not( user in users)):
                continue
            value = line_spl[1].split('+') 
            if (len( value) > 2 or len( value) == 0):
                return -1
            if (len( value) == 2):
                try:
                    min_cores = int(value[0])
                    left_cores += users_min[user] - min_cores
                    users_min[user] = min_cores
                    value.pop(0)
                except:
                    return -1
            users_extra[user] = value[0]
        if (left_cores < 0):
            return -2


        left_cores_original = left_cores
        for user,info in users_extra.iteritems():
            try:
                if (info[-1] == '%'):
                    N_per_user = float(info[:-1])
                    N_per_user = int(N_per_user*left_cores_original/100)
                else:
                    N_per_user = int(info)
            except:
                return -1

            add_cores = N_per_user
            left_cores -= add_cores
            users_extra[user] = add_cores

    else:
        return -3

    while (left_cores != 0):
        for user in users_extra:
            if (left_cores == 0):
                break
            users_extra[user] += int(math.copysign(1,left_cores))
            left_cores += math.copysign(1,-left_cores)

    if(verbose):
        print "users_min: ", users_min
        print "users_extra: ", users_extra

    global N_min_cores
    N_min_cores = 0
    for user in users:
        try:
            users[user].min_cores = users_min[user]
        except:
            users[user].min_cores = 0
        N_min_cores += users[user].min_cores
        try:
            users[user].extra_cores = users_extra[user]
        except:
            users[user].extra_cores = 0
        
    for user in users:
        users[user].max_cores = N_cores - N_min_cores + users[user].min_cores

    f.close()
    return 0



# Get action from client and execute it
# message from client must be:
#   (action_type, arguments)
#              
#   The arguments are option dependent. See below
#
def handle_client( ):
    global N_cores
    if (verbose):
        print "handle_client: ready"
    server = Listener(( multiuser_address, multiuser_port), authkey = multiuser_key)
    while True:
        client = server.accept()
        (action_type, arguments) = client.recv()
        if (verbose):
            print "Received: " + str(action_type) + " -> " + str(arguments)


        # Reload the nodes
        # arguments = ()
        if (action_type == MULTIUSER_NODES):
            load_nodes()
            try:
                msg = (0, 'Nodes loaded.')
            except:
                msg = (1, 'Problem when loading nodes. Is this the correct file: ' + nodes_file + '?')
            client.send( msg)


        # Redistribute cores
        # arguments = ()
        elif (action_type == MULTIUSER_DISTRIBUTE):
            status = distribute_cores()
            if (status != 0):
                msg = (1, 'Cores distribution failed.')
            else:
                msg = (0, 'Cores distributed.')
            client.send( msg)


        # Show status
        # arguments = ()
        elif (action_type == MULTIUSER_STATUS):
            Umsg = ''
            for user, info in users.iteritems():
                Umsg += '  ' + user + ': ' + str( info.n_jobs) + '+' + str( info.n_queue) + '/' + str( info.min_cores)
                if (info.extra_cores > 0):
                    Umsg += '+' + str(info.extra_cores) + '\n'
                else:
                    Umsg += '\n'
            if (Umsg):
                Umsg = 'Users:\n' + Umsg
            else:
                Umsg = 'No users.\n'
            Nmsg = ''
            for node, info in nodes.iteritems():
                Nmsg += '  ' + node + ': ' + str( info.n_jobs) + '/' + str( info.max_jobs) + '\n'
            if (Nmsg):
                Nmsg = 'Nodes:\n' + Nmsg
            else:
                Nmsg = 'No nodes.\n'
            msg = Umsg + Nmsg
            msg = msg + 'Cores: ' + str(N_jobs) + '/' + str( N_cores)
            client.send( (0, msg))


        # Finish qpy-multiuser
        # arguments = ()
        elif (action_type == MULTIUSER_FINISH):
            client.send( (0, 'Finishing qpy-multiuser.'))
            break


        # Add a user
        # arguments = (user_name, cur_jobs)
        elif (action_type == MULTIUSER_USER):
            user = arguments[0]
            if (user in users):
                if (arguments[1]):
                    if (verbose):
                        print "Adding cur_jobs to user."
                    users[user].cur_jobs = arguments[1]
                    users[user].n_jobs = 0
                    for job in users[user].cur_jobs:
                        nodes[job[1]].n_jobs += job[2]
                        N_cores += job[2]
                        users[user].n_jobs += job[2]
                msg = (0, 'User exists.')
            else:
                # Add allowed users
                allowed_users = []
                if (os.path.isfile( allowed_users_file)):
                    f = open( allowed_users_file, 'r')
                    for line in f:
                        allowed_users.append( line.strip())
                    f.close()
                if (user in allowed_users):
                    new_user = USER( user)
                    users[user] = new_user
                    if (arguments[1]):
                        if (verbose):
                            print "Adding cur_jobs to user."
                        users[user].cur_jobs = arguments[1]
                        users[user].n_jobs = 0
                        for job in users[user].cur_jobs:
                            nodes[job[1]].n_jobs += job[2]
                            N_cores += job[2]
                            users[user].n_jobs += job[2]
                    status = distribute_cores()
                    if (status != 0):
                        msg = (0, 'User added. Cores distribution failed.')
                    else:
                        msg = (0, 'User added.')
                else:
                    msg = (1, 'Not allowed user.')
                print msg
            client.send( (msg, nodes_file))


        # Require a core
        # arguments = (user_name, jobID, n_cores, queue_size)
        elif (action_type == MULTIUSER_REQ_CORE):
            try:
                alloc_status = users[arguments[0]].add_job( int(arguments[1]), int(arguments[2]))
                client.send( alloc_status)
                if ( alloc_status[0] == 0):
                    users[arguments[0]].n_queue = int(arguments[3]) - 1
                else:
                    users[arguments[0]].n_queue = int(arguments[3])
            except KeyError:
                client.send( (-1, 'User does not exists.'))
            except Exception as ex:
                template = "An exception of type {0} occured - require a core.\nArguments:\n{1!r}"
                msg = template.format(type(ex).__name__, ex.args)
                if (verbose):
                    print msg
                client.send( (-2, 'Exception raised:\n' + msg + '\nContact the qpy-team.'))


        # Remove a job
        # arguments = (user_name, jobID, queue_size)
        elif (action_type == MULTIUSER_REMOVE_JOB):
            try:
                rem_status = users[arguments[0]].remove_job( arguments[1])
                users[arguments[0]].n_queue = int(arguments[2])
                client.send( rem_status)
            except KeyError:
                client.send( (-1, 'User does not exists.'))
            except Exception as ex:
                template = "An exception of type {0} occured - free a core.\nArguments:\n{1!r}"
                msg = template.format(type(ex).__name__, ex.args)
                if (verbose):
                    print msg
                client.send( (-2, 'Exception raised:\n' + msg + '\nContact the qpy-team.'))


        # Unknown option
        else:
            client.send( (-1, 'Unknown option: ' + str( action_type)))

load_nodes()
handle_client()
