#!/usr/bin/python
# qpy - queueing manager for qpy
#
# 29 May 2015 - Pradipta and Yuri
from multiprocessing.connection import Client
from time import sleep
import os
import sys
import subprocess
import re
import threading
from qpyCommon import *

home_dir = os.environ['HOME']
user = os.environ['USER']
if (TEST_RUN):
    qpy_dir = os.path.expanduser( '~/.qpy-test/')
else:
    qpy_dir = os.path.expanduser( '~/.qpy/')

port_file = qpy_dir + '/port'
key_file = qpy_dir + '/conn_key'
tutorial_file = QPY_SOURCE_DIR + '/tutorial'

qpy_master_command = 'python ' + QPY_SOURCE_DIR + 'qpy-master.py'

# '--options' are to be called only by qpy-master, not by the users
if (len( sys.argv) > 1):
    if (sys.argv[1] == '--jobkill'):
        job_id = sys.argv[2]
        command = 'ps -fu ' + user
        kill_job_ps = subprocess.Popen(command,
                                       shell = True,
                                       stdout = subprocess.PIPE,
                                       stderr = subprocess.PIPE)
        ps_out = kill_job_ps.stdout.readlines()

        # Get calling PID and parents associations:
        grand_PID = ''
        parents = {}
        for l in ps_out:
            new_pid = l.split()
            parents[new_pid[1]] = new_pid[2]
            re_res = re.search('export QPY_JOB_ID=' + job_id + ';', l)
            if (re_res):
                grand_PID = new_pid[1]

        pid_kill = get_all_children( grand_PID, parents)
        pid_kill.reverse()
        for i in pid_kill:
            kill_job = subprocess.call(['kill', '-9', i])
            print 'Killing PID ' + i

        exit()
# end of '--options'


try:
    option = KEYWORDS[sys.argv[1]][0]
except:
    str_len = 0
    for opt in KEYWORDS:
        if (str_len < len( opt)):
            str_len = len( opt)
    format_spc = '{0:' + str( str_len+1) + 's}'
    usage_msg =  'Usage: ' + sys.argv[0] +  ' <option> [<arguments>].\n'
    usage_msg += 'Options:'
    for opt in KEYWORDS:
        usage_msg += '\n  ' + format_spc.format( opt+':') + ' ' + KEYWORDS[opt][1]
    sys.exit( usage_msg)

start_qpy_master = option == JOBTYPE_RESTART
if (start_qpy_master):
    option = JOBTYPE_FINISH

# Get arguments, according to the option
arguments = ()

# Submit a job
if (option == JOBTYPE_SUB):
    job = ''
    for i in sys.argv[2:]:
        job += ' ' + i
    arguments = [job, os.getcwd()]

# Check jobs
if (option == JOBTYPE_CHECK):
    arguments = {}
    for x in sys.argv[2:]:
        if x in JOB_STATUS:
            if ('status' in arguments):
                arguments['status'].append( x)
            else:
                arguments['status'] = [x]
        else:
            try:
                new_jobids = string_to_int_list( x)
            except:
                sys.exit( 'Unknown pattern for checking jobs: ' + x)
            if ('job_id' in arguments):
                arguments['job_id'].extend( new_jobids)
            else:
                arguments['job_id'] = new_jobids

# Config
elif (option == JOBTYPE_CONFIG):
    if (len(sys.argv) == 4):
        arguments = (sys.argv[2], sys.argv[3])
    elif (len( sys.argv) > 4):
        arguments = (sys.argv[2], sys.argv[3:])
    elif (len( sys.argv) == 3):
        arguments = (sys.argv[2], ())

# Kill jobs or clean list
elif (option == JOBTYPE_KILL or option == JOBTYPE_CLEAN):
    if option == JOBTYPE_KILL:
        status_bound = (0,2)
    else:
        status_bound = (2,5)
    arguments = []
    for x in sys.argv[2:]:
        try:
            new_range = string_to_int_list( x)
            arguments.extend( new_range)
        except:
            if (x == 'all' or x in JOB_STATUS[status_bound[0]:status_bound[1]]):
                arguments.append( x)
            else:
                sys.exit( 'Range with wrong format or invalid status: ' + x)

    arguments = list( set( arguments))

# Control queue
elif (option == JOBTYPE_CTRLQUEUE):
    if (len( sys.argv) < 3):
        sys.exit( 'Give the queue control type.')
    else:
        if (sys.argv[2] == 'jump'):
            new_range = []
            for x in sys.argv[3:-1]:
                try:
                    new_range.extend( string_to_int_list( x))
                except:
                    sys.exit( 'Range with wrong format: ' + x)
            if (not( new_range)):
                    sys.exit( 'Give the jobs to change position.')
            try:
                pos = int( sys.argv[-1])
            except:
                if (sys.argv[-1] == 'begin'):
                    pos = 0
                elif (sys.argv[-1] == 'end'):
                    pos = -1
                else:
                    sys.exit( 'Invalid jump position: ' + sys.argv[-1])
            arguments = ('jump', new_range, pos)

        else:
            arguments = sys.argv[2:]

# Notes
elif (option == JOBTYPE_NOTE):
    if (len( sys.argv) < 3):
        arguments = ()
    elif (len( sys.argv) == 3):
        arguments = [ sys.argv[2]]
    else:
        arguments = [ sys.argv[2], ' '.join( sys.argv[3:])]

# The qpy tutorial
elif (option == JOBTYPE_TUTORIAL):
    
    pattern = ''
    for i in sys.argv[2:3]:
        pattern += i
    for i in sys.argv[3:]:
        pattern += ' ' + i

    if (pattern in KEYWORDS):
        pattern = '--pattern "# ' + pattern + '"'
    elif (pattern):
        pattern = '--pattern "' + pattern + '"'

    command = 'less '  + pattern + ' ' + tutorial_file
    try:
        subprocess.call( command, shell = True)
    except:
        sys.exit( 'Error when loading the tutorial.')
    exit()


try:
    f = open(port_file, 'r')
    port = int(f.read())
    f.close()
    f = open(key_file, 'r')
    conn_key = f.read()
    f.close()
except:
    if (start_qpy_master):
        start_master_driver(user, qpy_master_command)
    else:
        sys.exit('Problem to get the connection information. Are you sure that qpy-master is running?')

try:
    master_msg = message_transfer((option, arguments),
                                  ADDRESS,
                                  port,
                                  conn_key,
                                  timeout = 3.0)
except:
    if (start_qpy_master):
        os.remove(port_file)
        os.remove(key_file)
        start_master_driver(user, qpy_master_command)
    sys.exit('Time for connection exceeded. Are you sure that qpy-master is running?')

ansi_escape = re.compile(r'\x1b[^m]*m')
if (not(sys.stdout.isatty())):
    master_msg = ansi_escape.sub('', master_msg)
sys.stdout.write(master_msg)

if (start_qpy_master):
    start_master_driver(user, qpy_master_command)
